# Vue基础

## vue生命周期

````
1.有哪些生命周期
系统自带:
- beforeCreate
- created
- beforeMount
- mounted
- beforeUpdate
- updated
- beforeDestroy
- destoryed
2.一旦进入到页面或者组件,会执行哪些生命周期,顺序
- beforeCreate
- created
- beforeMount
- mounted
3.在哪个阶段有$el,在哪个阶段有$data
- beforeCreate 啥也没有
- created有data 没有el
- beforeMount有data 没有el
- mounted 都有
- 后面也都有
4.如果假如keep-alive会多两个生命周期
- activated 进入
- deactivated 离开销毁
5.如果加入了keep-alive,第一次进入会执行哪些生命周期
- beforeCreate
- created
- beforeMount
- mounted
- activated 进入
6.如果加入了keep-alive,第二次或者第N次会执行哪些生命周期
- activated 进入  只执行一个生命周期,页面被缓存了
````

## 对keep-alive的了解

```
1.是生命
vue系统自带的一个组件,功能用来缓存组件的.提升性能
2.使用场景  
就算来缓存组件提升项目的性能.具体实现:首页进入到详情页,如果用户在首页每次点击都是相同的,那么详情页就没必要请求N次了,直接缓存起来就可以了.如果点击的不是同一个,那么就直接请求.
```

## v-if&v-show的区别

```
1.展示形式不同
v-if:创建一个节点
v-show:是display:none、block
2.使用场景不同
初次加载v-if要比v-show好,页面不会多加载盒子
频繁切换v-show要比v-if好,创建和删除的开销太大了,显示和隐藏的开销较小
```

## v-if和v-for优先级

```
 v-for的优先级要比v-if高  是在源码中体现的 function genElement
```

## ref是什么？

```
来获取dom的
this.$refs.xx
```

## nexttick是什么？

```js
//获取更新后的dom内容的
  created() {
    console.log("111", 111);
    this.$nextTick(() => {
      console.log("222", 222);
    });
  },
  mounted() {
    console.log("333", 333);
    this.$nextTick(() => {
      console.log("444", 444);
    });
  }
//111 333 222 444

```

js代码执行是同步的,<div>{{xx}}</div>中xx的修改赋值是异步的,更改后输出xx的值,输出出来是更改前的值,输出语句放在$nextTick里面即可得到更新后的值.

## scoped原理

```
 1.作用:让样式在本组件中生效,不影响到其他组件
 2.原理:给节点新增自定义属性,然后css根据属性选择器添加样式
```

## vue中如何做样式穿透

```
1.scss: 父元素 /deep/ 子元素
2.stylus： 父元素 /deep/ 子元素  父元素 >>> 子元素
```

## 组件通讯

```vue
//	父组件
<hello-world msg="hello world!" @confirm="handleConfirm"><hello-world>
//	子组件
 props: {
    msg: {
      type: String,
      default: ''
    }
  }，
  methods：{
  	handleEmitParent(){
  		this.$emit('confirm', list)
  	}
  } 
//兄弟之间的传值 bus
    A兄弟传值:
    import bus from "@/common/bus"
    bus.$emit("toXX",this.msg)
    B兄弟接受
    import bus from "@/common/bus"
    mounted(){
    	bus.$on("toXX",(data)=>{
    		this.str = data
		})
    }
    //bus.js    //也可以将$bus绑定全局
    import Vue from 'vue'
    export default new Vue
```

## computed methods watch有什么区别

```
1.computed vs methods区别
	computed是有缓存的,methods区别没有缓存
2.computed  vs watch区别
	watch是监听,数据或者路由发生了改变才可以执行
	computed计算某一个属性的改变,如果某个值改变了,计算属性会监听到并进行返回
	watch是当前监听到的数据改变了,才会执行内部代码
	
```

## vue设置代理

```
 //vue.config.js
 module.exports = {
  devServer: {
    proxy: 'http://localhost:4000'
  }
 }
```

## 打包路径和路由模式(空白页)

```
路由模式:history|hash#

前端如果自己测试项目,得用hash
项目上线要求是 history模式,该怎么办?重定向
```

## 代理和环境变量

```
根目录:
开发环境: .env.development
生产环境: .env

//console.log(process.env.VUE_APP_SECRET)
```

[模式和环境变量]: https://cli.vuejs.org/zh/guide/mode-and-env.html

